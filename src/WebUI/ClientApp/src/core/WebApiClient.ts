/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.9.4.0 (NJsonSchema v10.3.1.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import authService from "../auth/AuthorizeService";
export class ClientBase {

    protected transformOptions = async (options: RequestInit): Promise<RequestInit> => {
        let token = await authService.getAccessToken();
        options.headers = {
            ...options.headers,
            Authorization: 'Bearer ' + token,
        };
        return Promise.resolve(options);
    };
}

export interface IConversationsClient {
    create(command: CreateConversationCommand): Promise<number>;
}

export class ConversationsClient extends ClientBase implements IConversationsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(command: CreateConversationCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Conversations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }
}

export interface IFollowsClient {
    getUserFollows(userId: number): Promise<FollowsVM>;
    followUser(userId: number): Promise<FileResponse>;
    getSuggestions(count?: number | null | undefined): Promise<SuggestionUserDto[]>;
    unfollowUser(userId: number): Promise<FileResponse>;
}

export class FollowsClient extends ClientBase implements IFollowsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getUserFollows(userId: number): Promise<FollowsVM> {
        let url_ = this.baseUrl + "/api/users/{userId}/follows";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserFollows(_response);
        });
    }

    protected processGetUserFollows(response: Response): Promise<FollowsVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FollowsVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FollowsVM>(<any>null);
    }

    followUser(userId: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/users/{userId}/follows";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processFollowUser(_response);
        });
    }

    protected processFollowUser(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    getSuggestions(count?: number | null | undefined): Promise<SuggestionUserDto[]> {
        let url_ = this.baseUrl + "/api/Follows/suggestions?";
        if (count !== undefined && count !== null)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetSuggestions(_response);
        });
    }

    protected processGetSuggestions(response: Response): Promise<SuggestionUserDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SuggestionUserDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SuggestionUserDto[]>(<any>null);
    }

    unfollowUser(userId: number): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/users/{userId}/unfollow";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUnfollowUser(_response);
        });
    }

    protected processUnfollowUser(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export interface ILikesClient {
    createLike(postId: number): Promise<void>;
    removeLike(postId: number): Promise<void>;
}

export class LikesClient extends ClientBase implements ILikesClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createLike(postId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/posts/{postId}/like";
        if (postId === undefined || postId === null)
            throw new Error("The parameter 'postId' must be defined.");
        url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateLike(_response);
        });
    }

    protected processCreateLike(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    removeLike(postId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/posts/{postId}/like";
        if (postId === undefined || postId === null)
            throw new Error("The parameter 'postId' must be defined.");
        url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRemoveLike(_response);
        });
    }

    protected processRemoveLike(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export interface IMediasClient {
    get(id: string): Promise<FileResponse>;
    create(file?: FileParameter | null | undefined): Promise<string>;
}

export class MediasClient extends ClientBase implements IMediasClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(id: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Medias/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    create(file?: FileParameter | null | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Medias";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(<any>null);
    }
}

export interface INotificationsClient {
    get(count?: number | null | undefined, beforeId?: number | null | undefined): Promise<NotificationsVM>;
    markAsRead(id: number): Promise<void>;
}

export class NotificationsClient extends ClientBase implements INotificationsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(count?: number | null | undefined, beforeId?: number | null | undefined): Promise<NotificationsVM> {
        let url_ = this.baseUrl + "/api/Notifications?";
        if (count !== undefined && count !== null)
            url_ += "Count=" + encodeURIComponent("" + count) + "&";
        if (beforeId !== undefined && beforeId !== null)
            url_ += "BeforeId=" + encodeURIComponent("" + beforeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<NotificationsVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = NotificationsVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NotificationsVM>(<any>null);
    }

    markAsRead(id: number): Promise<void> {
        let url_ = this.baseUrl + "/api/Notifications/{id}/read";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processMarkAsRead(_response);
        });
    }

    protected processMarkAsRead(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export interface IPostsClient {
    getAll(beforeId?: number | null | undefined, count?: number | null | undefined): Promise<PostDto[]>;
    create(command: CreatePostCommand): Promise<number>;
    get(id: number): Promise<PostDto2>;
    getUserPosts(userId: number, beforeId?: number | null | undefined, count?: number | null | undefined): Promise<PostDto3[]>;
    getPostAnswers(postId: number, beforeId?: number | null | undefined, count?: number | null | undefined): Promise<PostDto4[]>;
}

export class PostsClient extends ClientBase implements IPostsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAll(beforeId?: number | null | undefined, count?: number | null | undefined): Promise<PostDto[]> {
        let url_ = this.baseUrl + "/api/Posts?";
        if (beforeId !== undefined && beforeId !== null)
            url_ += "BeforeId=" + encodeURIComponent("" + beforeId) + "&";
        if (count !== undefined && count !== null)
            url_ += "Count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: Response): Promise<PostDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PostDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PostDto[]>(<any>null);
    }

    create(command: CreatePostCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Posts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    get(id: number): Promise<PostDto2> {
        let url_ = this.baseUrl + "/api/Posts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<PostDto2> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PostDto2.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PostDto2>(<any>null);
    }

    getUserPosts(userId: number, beforeId?: number | null | undefined, count?: number | null | undefined): Promise<PostDto3[]> {
        let url_ = this.baseUrl + "/api/users/{userId}/posts?";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (beforeId !== undefined && beforeId !== null)
            url_ += "beforeId=" + encodeURIComponent("" + beforeId) + "&";
        if (count !== undefined && count !== null)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserPosts(_response);
        });
    }

    protected processGetUserPosts(response: Response): Promise<PostDto3[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PostDto3.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PostDto3[]>(<any>null);
    }

    getPostAnswers(postId: number, beforeId?: number | null | undefined, count?: number | null | undefined): Promise<PostDto4[]> {
        let url_ = this.baseUrl + "/api/Posts/{postId}/answers?";
        if (postId === undefined || postId === null)
            throw new Error("The parameter 'postId' must be defined.");
        url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
        if (beforeId !== undefined && beforeId !== null)
            url_ += "beforeId=" + encodeURIComponent("" + beforeId) + "&";
        if (count !== undefined && count !== null)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetPostAnswers(_response);
        });
    }

    protected processGetPostAnswers(response: Response): Promise<PostDto4[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PostDto4.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PostDto4[]>(<any>null);
    }
}

export interface IRePostsClient {
    createRePost(postId: number): Promise<void>;
    removeRePost(postId: number): Promise<void>;
}

export class RePostsClient extends ClientBase implements IRePostsClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createRePost(postId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/posts/{postId}/re-post";
        if (postId === undefined || postId === null)
            throw new Error("The parameter 'postId' must be defined.");
        url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateRePost(_response);
        });
    }

    protected processCreateRePost(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    removeRePost(postId: number): Promise<void> {
        let url_ = this.baseUrl + "/api/posts/{postId}/re-post";
        if (postId === undefined || postId === null)
            throw new Error("The parameter 'postId' must be defined.");
        url_ = url_.replace("{postId}", encodeURIComponent("" + postId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "DELETE",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRemoveRePost(_response);
        });
    }

    protected processRemoveRePost(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export interface IUsersClient {
    create(command: CreateUserCommand): Promise<number>;
    get(applicationUserId?: string | null | undefined): Promise<UserDto7>;
    update(command: UpdateUserCommand): Promise<void>;
    get2(id: number): Promise<UserDto6>;
    getUserProfile(username: string | null): Promise<UserProfileVM>;
    searchUser(q?: string | null | undefined): Promise<SearchUserDto[]>;
}

export class UsersClient extends ClientBase implements IUsersClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(command: CreateUserCommand): Promise<number> {
        let url_ = this.baseUrl + "/api/Users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(<any>null);
    }

    get(applicationUserId?: string | null | undefined): Promise<UserDto7> {
        let url_ = this.baseUrl + "/api/Users?";
        if (applicationUserId !== undefined && applicationUserId !== null)
            url_ += "applicationUserId=" + encodeURIComponent("" + applicationUserId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: Response): Promise<UserDto7> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto7.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto7>(<any>null);
    }

    update(command: UpdateUserCommand): Promise<void> {
        let url_ = this.baseUrl + "/api/Users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }

    get2(id: number): Promise<UserDto6> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGet2(_response);
        });
    }

    protected processGet2(response: Response): Promise<UserDto6> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDto6.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto6>(<any>null);
    }

    getUserProfile(username: string | null): Promise<UserProfileVM> {
        let url_ = this.baseUrl + "/api/Users/{username}/profile";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetUserProfile(_response);
        });
    }

    protected processGetUserProfile(response: Response): Promise<UserProfileVM> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserProfileVM.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserProfileVM>(<any>null);
    }

    searchUser(q?: string | null | undefined): Promise<SearchUserDto[]> {
        let url_ = this.baseUrl + "/api/Users/search?";
        if (q !== undefined && q !== null)
            url_ += "q=" + encodeURIComponent("" + q) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSearchUser(_response);
        });
    }

    protected processSearchUser(response: Response): Promise<SearchUserDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SearchUserDto.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SearchUserDto[]>(<any>null);
    }
}

export class CreateConversationCommand implements ICreateConversationCommand {
    members?: number[] | undefined;

    constructor(data?: ICreateConversationCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["members"])) {
                this.members = [] as any;
                for (let item of _data["members"])
                    this.members!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateConversationCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateConversationCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item);
        }
        return data; 
    }
}

export interface ICreateConversationCommand {
    members?: number[] | undefined;
}

export class FollowsVM implements IFollowsVM {
    followerIds?: number[] | undefined;
    followedIds?: number[] | undefined;

    constructor(data?: IFollowsVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["followerIds"])) {
                this.followerIds = [] as any;
                for (let item of _data["followerIds"])
                    this.followerIds!.push(item);
            }
            if (Array.isArray(_data["followedIds"])) {
                this.followedIds = [] as any;
                for (let item of _data["followedIds"])
                    this.followedIds!.push(item);
            }
        }
    }

    static fromJS(data: any): FollowsVM {
        data = typeof data === 'object' ? data : {};
        let result = new FollowsVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.followerIds)) {
            data["followerIds"] = [];
            for (let item of this.followerIds)
                data["followerIds"].push(item);
        }
        if (Array.isArray(this.followedIds)) {
            data["followedIds"] = [];
            for (let item of this.followedIds)
                data["followedIds"].push(item);
        }
        return data; 
    }
}

export interface IFollowsVM {
    followerIds?: number[] | undefined;
    followedIds?: number[] | undefined;
}

export class SuggestionUserDto implements ISuggestionUserDto {
    id?: number;
    fullName?: string | undefined;
    username?: string | undefined;
    pictureId?: string | undefined;
    isCertified?: boolean;

    constructor(data?: ISuggestionUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.username = _data["username"];
            this.pictureId = _data["pictureId"];
            this.isCertified = _data["isCertified"];
        }
    }

    static fromJS(data: any): SuggestionUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new SuggestionUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["username"] = this.username;
        data["pictureId"] = this.pictureId;
        data["isCertified"] = this.isCertified;
        return data; 
    }
}

export interface ISuggestionUserDto {
    id?: number;
    fullName?: string | undefined;
    username?: string | undefined;
    pictureId?: string | undefined;
    isCertified?: boolean;
}

export class NotificationsVM implements INotificationsVM {
    notifications?: NotificationDto[] | undefined;
    totalUnread?: number;

    constructor(data?: INotificationsVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(NotificationDto.fromJS(item));
            }
            this.totalUnread = _data["totalUnread"];
        }
    }

    static fromJS(data: any): NotificationsVM {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationsVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        data["totalUnread"] = this.totalUnread;
        return data; 
    }
}

export interface INotificationsVM {
    notifications?: NotificationDto[] | undefined;
    totalUnread?: number;
}

export class NotificationDto implements INotificationDto {
    id?: number;
    read?: boolean;
    postId?: number;
    postContent?: string | undefined;
    createdBy?: UserDto | undefined;
    type?: NotificationType;

    constructor(data?: INotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.read = _data["read"];
            this.postId = _data["postId"];
            this.postContent = _data["postContent"];
            this.createdBy = _data["createdBy"] ? UserDto.fromJS(_data["createdBy"]) : <any>undefined;
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): NotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["read"] = this.read;
        data["postId"] = this.postId;
        data["postContent"] = this.postContent;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["type"] = this.type;
        return data; 
    }
}

export interface INotificationDto {
    id?: number;
    read?: boolean;
    postId?: number;
    postContent?: string | undefined;
    createdBy?: UserDto | undefined;
    type?: NotificationType;
}

export class UserDto implements IUserDto {
    id?: number;
    fullName?: string | undefined;
    username?: string | undefined;
    pictureId?: string | undefined;
    isCertified?: boolean;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.username = _data["username"];
            this.pictureId = _data["pictureId"];
            this.isCertified = _data["isCertified"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["username"] = this.username;
        data["pictureId"] = this.pictureId;
        data["isCertified"] = this.isCertified;
        return data; 
    }
}

export interface IUserDto {
    id?: number;
    fullName?: string | undefined;
    username?: string | undefined;
    pictureId?: string | undefined;
    isCertified?: boolean;
}

export enum NotificationType {
    Follow = 0,
    Mention = 1,
    Answer = 2,
    RePost = 3,
    Like = 4,
}

export class PostDto implements IPostDto {
    id?: number;
    answerToId?: number | undefined;
    content?: string | undefined;
    created?: Date;
    createdBy?: UserDto2 | undefined;
    mediaId?: string | undefined;
    likedBy?: UserDto2 | undefined;
    likedByMe?: boolean;
    likes?: number;
    rePostedBy?: UserDto2 | undefined;
    rePostedByMe?: boolean;
    rePosts?: number;
    answers?: number;

    constructor(data?: IPostDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.answerToId = _data["answerToId"];
            this.content = _data["content"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"] ? UserDto2.fromJS(_data["createdBy"]) : <any>undefined;
            this.mediaId = _data["mediaId"];
            this.likedBy = _data["likedBy"] ? UserDto2.fromJS(_data["likedBy"]) : <any>undefined;
            this.likedByMe = _data["likedByMe"];
            this.likes = _data["likes"];
            this.rePostedBy = _data["rePostedBy"] ? UserDto2.fromJS(_data["rePostedBy"]) : <any>undefined;
            this.rePostedByMe = _data["rePostedByMe"];
            this.rePosts = _data["rePosts"];
            this.answers = _data["answers"];
        }
    }

    static fromJS(data: any): PostDto {
        data = typeof data === 'object' ? data : {};
        let result = new PostDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["answerToId"] = this.answerToId;
        data["content"] = this.content;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["mediaId"] = this.mediaId;
        data["likedBy"] = this.likedBy ? this.likedBy.toJSON() : <any>undefined;
        data["likedByMe"] = this.likedByMe;
        data["likes"] = this.likes;
        data["rePostedBy"] = this.rePostedBy ? this.rePostedBy.toJSON() : <any>undefined;
        data["rePostedByMe"] = this.rePostedByMe;
        data["rePosts"] = this.rePosts;
        data["answers"] = this.answers;
        return data; 
    }
}

export interface IPostDto {
    id?: number;
    answerToId?: number | undefined;
    content?: string | undefined;
    created?: Date;
    createdBy?: UserDto2 | undefined;
    mediaId?: string | undefined;
    likedBy?: UserDto2 | undefined;
    likedByMe?: boolean;
    likes?: number;
    rePostedBy?: UserDto2 | undefined;
    rePostedByMe?: boolean;
    rePosts?: number;
    answers?: number;
}

export class UserDto2 implements IUserDto2 {
    id?: number;
    fullName?: string | undefined;
    username?: string | undefined;
    pictureId?: string | undefined;
    isCertified?: boolean;

    constructor(data?: IUserDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.username = _data["username"];
            this.pictureId = _data["pictureId"];
            this.isCertified = _data["isCertified"];
        }
    }

    static fromJS(data: any): UserDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["username"] = this.username;
        data["pictureId"] = this.pictureId;
        data["isCertified"] = this.isCertified;
        return data; 
    }
}

export interface IUserDto2 {
    id?: number;
    fullName?: string | undefined;
    username?: string | undefined;
    pictureId?: string | undefined;
    isCertified?: boolean;
}

export class PostDto2 implements IPostDto2 {
    id?: number;
    answerToId?: number | undefined;
    content?: string | undefined;
    created?: Date;
    createdBy?: UserDto3 | undefined;
    mediaId?: string | undefined;
    likedByMe?: boolean;
    likes?: number;
    rePostedByMe?: boolean;
    rePosts?: number;
    answers?: number;

    constructor(data?: IPostDto2) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.answerToId = _data["answerToId"];
            this.content = _data["content"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"] ? UserDto3.fromJS(_data["createdBy"]) : <any>undefined;
            this.mediaId = _data["mediaId"];
            this.likedByMe = _data["likedByMe"];
            this.likes = _data["likes"];
            this.rePostedByMe = _data["rePostedByMe"];
            this.rePosts = _data["rePosts"];
            this.answers = _data["answers"];
        }
    }

    static fromJS(data: any): PostDto2 {
        data = typeof data === 'object' ? data : {};
        let result = new PostDto2();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["answerToId"] = this.answerToId;
        data["content"] = this.content;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["mediaId"] = this.mediaId;
        data["likedByMe"] = this.likedByMe;
        data["likes"] = this.likes;
        data["rePostedByMe"] = this.rePostedByMe;
        data["rePosts"] = this.rePosts;
        data["answers"] = this.answers;
        return data; 
    }
}

export interface IPostDto2 {
    id?: number;
    answerToId?: number | undefined;
    content?: string | undefined;
    created?: Date;
    createdBy?: UserDto3 | undefined;
    mediaId?: string | undefined;
    likedByMe?: boolean;
    likes?: number;
    rePostedByMe?: boolean;
    rePosts?: number;
    answers?: number;
}

export class UserDto3 implements IUserDto3 {
    id?: number;
    fullName?: string | undefined;
    username?: string | undefined;
    pictureId?: string | undefined;
    isCertified?: boolean;

    constructor(data?: IUserDto3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.username = _data["username"];
            this.pictureId = _data["pictureId"];
            this.isCertified = _data["isCertified"];
        }
    }

    static fromJS(data: any): UserDto3 {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["username"] = this.username;
        data["pictureId"] = this.pictureId;
        data["isCertified"] = this.isCertified;
        return data; 
    }
}

export interface IUserDto3 {
    id?: number;
    fullName?: string | undefined;
    username?: string | undefined;
    pictureId?: string | undefined;
    isCertified?: boolean;
}

export class CreatePostCommand implements ICreatePostCommand {
    content?: string | undefined;
    mediaId?: string | undefined;
    answerToId?: number | undefined;

    constructor(data?: ICreatePostCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.content = _data["content"];
            this.mediaId = _data["mediaId"];
            this.answerToId = _data["answerToId"];
        }
    }

    static fromJS(data: any): CreatePostCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePostCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["content"] = this.content;
        data["mediaId"] = this.mediaId;
        data["answerToId"] = this.answerToId;
        return data; 
    }
}

export interface ICreatePostCommand {
    content?: string | undefined;
    mediaId?: string | undefined;
    answerToId?: number | undefined;
}

export class PostDto3 implements IPostDto3 {
    id?: number;
    answerToId?: number | undefined;
    content?: string | undefined;
    created?: Date;
    createdBy?: UserDto4 | undefined;
    mediaId?: string | undefined;
    likedByMe?: boolean;
    likes?: number;
    rePostedByMe?: boolean;
    rePosts?: number;
    answers?: number;

    constructor(data?: IPostDto3) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.answerToId = _data["answerToId"];
            this.content = _data["content"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"] ? UserDto4.fromJS(_data["createdBy"]) : <any>undefined;
            this.mediaId = _data["mediaId"];
            this.likedByMe = _data["likedByMe"];
            this.likes = _data["likes"];
            this.rePostedByMe = _data["rePostedByMe"];
            this.rePosts = _data["rePosts"];
            this.answers = _data["answers"];
        }
    }

    static fromJS(data: any): PostDto3 {
        data = typeof data === 'object' ? data : {};
        let result = new PostDto3();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["answerToId"] = this.answerToId;
        data["content"] = this.content;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["mediaId"] = this.mediaId;
        data["likedByMe"] = this.likedByMe;
        data["likes"] = this.likes;
        data["rePostedByMe"] = this.rePostedByMe;
        data["rePosts"] = this.rePosts;
        data["answers"] = this.answers;
        return data; 
    }
}

export interface IPostDto3 {
    id?: number;
    answerToId?: number | undefined;
    content?: string | undefined;
    created?: Date;
    createdBy?: UserDto4 | undefined;
    mediaId?: string | undefined;
    likedByMe?: boolean;
    likes?: number;
    rePostedByMe?: boolean;
    rePosts?: number;
    answers?: number;
}

export class UserDto4 implements IUserDto4 {
    id?: number;
    fullName?: string | undefined;
    username?: string | undefined;
    pictureId?: string | undefined;
    isCertified?: boolean;

    constructor(data?: IUserDto4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.username = _data["username"];
            this.pictureId = _data["pictureId"];
            this.isCertified = _data["isCertified"];
        }
    }

    static fromJS(data: any): UserDto4 {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["username"] = this.username;
        data["pictureId"] = this.pictureId;
        data["isCertified"] = this.isCertified;
        return data; 
    }
}

export interface IUserDto4 {
    id?: number;
    fullName?: string | undefined;
    username?: string | undefined;
    pictureId?: string | undefined;
    isCertified?: boolean;
}

export class PostDto4 implements IPostDto4 {
    id?: number;
    answerToId?: number | undefined;
    content?: string | undefined;
    created?: Date;
    createdBy?: UserDto5 | undefined;
    mediaId?: string | undefined;
    likedByMe?: boolean;
    likes?: number;
    rePostedByMe?: boolean;
    rePosts?: number;
    answers?: number;

    constructor(data?: IPostDto4) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.answerToId = _data["answerToId"];
            this.content = _data["content"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"] ? UserDto5.fromJS(_data["createdBy"]) : <any>undefined;
            this.mediaId = _data["mediaId"];
            this.likedByMe = _data["likedByMe"];
            this.likes = _data["likes"];
            this.rePostedByMe = _data["rePostedByMe"];
            this.rePosts = _data["rePosts"];
            this.answers = _data["answers"];
        }
    }

    static fromJS(data: any): PostDto4 {
        data = typeof data === 'object' ? data : {};
        let result = new PostDto4();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["answerToId"] = this.answerToId;
        data["content"] = this.content;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy ? this.createdBy.toJSON() : <any>undefined;
        data["mediaId"] = this.mediaId;
        data["likedByMe"] = this.likedByMe;
        data["likes"] = this.likes;
        data["rePostedByMe"] = this.rePostedByMe;
        data["rePosts"] = this.rePosts;
        data["answers"] = this.answers;
        return data; 
    }
}

export interface IPostDto4 {
    id?: number;
    answerToId?: number | undefined;
    content?: string | undefined;
    created?: Date;
    createdBy?: UserDto5 | undefined;
    mediaId?: string | undefined;
    likedByMe?: boolean;
    likes?: number;
    rePostedByMe?: boolean;
    rePosts?: number;
    answers?: number;
}

export class UserDto5 implements IUserDto5 {
    id?: number;
    fullName?: string | undefined;
    username?: string | undefined;
    pictureId?: string | undefined;
    isCertified?: boolean;

    constructor(data?: IUserDto5) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.username = _data["username"];
            this.pictureId = _data["pictureId"];
            this.isCertified = _data["isCertified"];
        }
    }

    static fromJS(data: any): UserDto5 {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto5();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["username"] = this.username;
        data["pictureId"] = this.pictureId;
        data["isCertified"] = this.isCertified;
        return data; 
    }
}

export interface IUserDto5 {
    id?: number;
    fullName?: string | undefined;
    username?: string | undefined;
    pictureId?: string | undefined;
    isCertified?: boolean;
}

export class CreateUserCommand implements ICreateUserCommand {
    fullName?: string | undefined;
    username?: string | undefined;
    applicationUserId?: string | undefined;

    constructor(data?: ICreateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.username = _data["username"];
            this.applicationUserId = _data["applicationUserId"];
        }
    }

    static fromJS(data: any): CreateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["username"] = this.username;
        data["applicationUserId"] = this.applicationUserId;
        return data; 
    }
}

export interface ICreateUserCommand {
    fullName?: string | undefined;
    username?: string | undefined;
    applicationUserId?: string | undefined;
}

export class UserDto6 implements IUserDto6 {
    id?: number;
    fullName?: string | undefined;
    username?: string | undefined;

    constructor(data?: IUserDto6) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.username = _data["username"];
        }
    }

    static fromJS(data: any): UserDto6 {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto6();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["username"] = this.username;
        return data; 
    }
}

export interface IUserDto6 {
    id?: number;
    fullName?: string | undefined;
    username?: string | undefined;
}

export class UserDto7 implements IUserDto7 {
    id?: number;
    fullName?: string | undefined;
    username?: string | undefined;
    applicationUserId?: string | undefined;
    pictureId?: string | undefined;

    constructor(data?: IUserDto7) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.username = _data["username"];
            this.applicationUserId = _data["applicationUserId"];
            this.pictureId = _data["pictureId"];
        }
    }

    static fromJS(data: any): UserDto7 {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto7();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["username"] = this.username;
        data["applicationUserId"] = this.applicationUserId;
        data["pictureId"] = this.pictureId;
        return data; 
    }
}

export interface IUserDto7 {
    id?: number;
    fullName?: string | undefined;
    username?: string | undefined;
    applicationUserId?: string | undefined;
    pictureId?: string | undefined;
}

export class UserProfileVM implements IUserProfileVM {
    user?: ProfileUserDto | undefined;
    postsCount?: number;
    followersCount?: number;
    followedCount?: number;

    constructor(data?: IUserProfileVM) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? ProfileUserDto.fromJS(_data["user"]) : <any>undefined;
            this.postsCount = _data["postsCount"];
            this.followersCount = _data["followersCount"];
            this.followedCount = _data["followedCount"];
        }
    }

    static fromJS(data: any): UserProfileVM {
        data = typeof data === 'object' ? data : {};
        let result = new UserProfileVM();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["postsCount"] = this.postsCount;
        data["followersCount"] = this.followersCount;
        data["followedCount"] = this.followedCount;
        return data; 
    }
}

export interface IUserProfileVM {
    user?: ProfileUserDto | undefined;
    postsCount?: number;
    followersCount?: number;
    followedCount?: number;
}

export class ProfileUserDto implements IProfileUserDto {
    id?: number;
    fullName?: string | undefined;
    username?: string | undefined;
    created?: Date;
    pictureId?: string | undefined;
    bannerId?: string | undefined;
    description?: string | undefined;
    website?: string | undefined;
    location?: string | undefined;
    isCertified?: boolean;

    constructor(data?: IProfileUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.username = _data["username"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.pictureId = _data["pictureId"];
            this.bannerId = _data["bannerId"];
            this.description = _data["description"];
            this.website = _data["website"];
            this.location = _data["location"];
            this.isCertified = _data["isCertified"];
        }
    }

    static fromJS(data: any): ProfileUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProfileUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["username"] = this.username;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["pictureId"] = this.pictureId;
        data["bannerId"] = this.bannerId;
        data["description"] = this.description;
        data["website"] = this.website;
        data["location"] = this.location;
        data["isCertified"] = this.isCertified;
        return data; 
    }
}

export interface IProfileUserDto {
    id?: number;
    fullName?: string | undefined;
    username?: string | undefined;
    created?: Date;
    pictureId?: string | undefined;
    bannerId?: string | undefined;
    description?: string | undefined;
    website?: string | undefined;
    location?: string | undefined;
    isCertified?: boolean;
}

export class UpdateUserCommand implements IUpdateUserCommand {
    fullName?: string | undefined;
    description?: string | undefined;
    location?: string | undefined;
    website?: string | undefined;
    pictureId?: string | undefined;
    bannerId?: string | undefined;

    constructor(data?: IUpdateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.description = _data["description"];
            this.location = _data["location"];
            this.website = _data["website"];
            this.pictureId = _data["pictureId"];
            this.bannerId = _data["bannerId"];
        }
    }

    static fromJS(data: any): UpdateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["description"] = this.description;
        data["location"] = this.location;
        data["website"] = this.website;
        data["pictureId"] = this.pictureId;
        data["bannerId"] = this.bannerId;
        return data; 
    }
}

export interface IUpdateUserCommand {
    fullName?: string | undefined;
    description?: string | undefined;
    location?: string | undefined;
    website?: string | undefined;
    pictureId?: string | undefined;
    bannerId?: string | undefined;
}

export class SearchUserDto implements ISearchUserDto {
    id?: number;
    fullName?: string | undefined;
    username?: string | undefined;
    pictureId?: string | undefined;
    followedByMe?: boolean;

    constructor(data?: ISearchUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.username = _data["username"];
            this.pictureId = _data["pictureId"];
            this.followedByMe = _data["followedByMe"];
        }
    }

    static fromJS(data: any): SearchUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new SearchUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["username"] = this.username;
        data["pictureId"] = this.pictureId;
        data["followedByMe"] = this.followedByMe;
        return data; 
    }
}

export interface ISearchUserDto {
    id?: number;
    fullName?: string | undefined;
    username?: string | undefined;
    pictureId?: string | undefined;
    followedByMe?: boolean;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}